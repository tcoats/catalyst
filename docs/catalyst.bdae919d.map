{"version":3,"sources":["src/vnode.ts","src/is.ts","src/h.ts","node_modules/fast-deep-equal/index.js","node_modules/odoql2/index.js","node_modules/injectinto/inject.js","node_modules/isarray/index.js","node_modules/path-to-regexp/index.js","node_modules/odo-route/index.js","../../../../usr/local/lib/node_modules/parcel/node_modules/process/browser.js","node_modules/page/page.js","default.js","error.js","../src/vnode.ts","../src/is.ts","../src/htmldomapi.ts","../src/h.ts","../src/thunk.ts","../src/snabbdom.ts","../src/modules/class.ts","../src/modules/props.ts","../src/modules/attributes.ts","../src/modules/style.ts","../src/modules/eventlisteners.ts","node_modules/odo-hub/index.js","node_modules/odoql2/exe.js","index.js"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","h","require","default","ql","inject","route","page","hub","exe","p","alert","component","query","state","params","render","attrs","href","message","patch","init","current","document","querySelector","update","next","Hub","results","one","Object","assign","clear","exec","canonicalPath","window","scrollTo","many","pod","hashbang"],"mappings":"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","file":"catalyst.bdae919d.map","sourceRoot":"..","sourcesContent":["import {Hooks} from './hooks';\nimport {AttachData} from './helpers/attachto'\nimport {VNodeStyle} from './modules/style'\nimport {On} from './modules/eventlisteners'\nimport {Attrs} from './modules/attributes'\nimport {Classes} from './modules/class'\nimport {Props} from './modules/props'\nimport {Dataset} from './modules/dataset'\nimport {Hero} from './modules/hero'\n\nexport type Key = string | number;\n\nexport interface VNode {\n  sel: string | undefined;\n  data: VNodeData | undefined;\n  children: Array<VNode | string> | undefined;\n  elm: Node | undefined;\n  text: string | undefined;\n  key: Key | undefined;\n}\n\nexport interface VNodeData {\n  props?: Props;\n  attrs?: Attrs;\n  class?: Classes;\n  style?: VNodeStyle;\n  dataset?: Dataset;\n  on?: On;\n  hero?: Hero;\n  attachData?: AttachData;\n  hook?: Hooks;\n  key?: Key;\n  ns?: string; // for SVGs\n  fn?: () => VNode; // for thunks\n  args?: Array<any>; // for thunks\n  [key: string]: any; // for any other 3rd party module\n}\n\nexport function vnode(sel: string | undefined,\n                      data: any | undefined,\n                      children: Array<VNode | string> | undefined,\n                      text: string | undefined,\n                      elm: Element | Text | undefined): VNode {\n  let key = data === undefined ? undefined : data.key;\n  return {sel: sel, data: data, children: children,\n          text: text, elm: elm, key: key};\n}\n\nexport default vnode;\n","export const array = Array.isArray;\nexport function primitive(s: any): s is (string | number) {\n  return typeof s === 'string' || typeof s === 'number';\n}\n","import {vnode, VNode, VNodeData} from './vnode';\nexport type VNodes = Array<VNode>;\nexport type VNodeChildElement = VNode | string | number | undefined | null;\nexport type ArrayOrElement<T> = T | T[];\nexport type VNodeChildren = ArrayOrElement<VNodeChildElement>\nimport * as is from './is';\n\nfunction addNS(data: any, children: VNodes | undefined, sel: string | undefined): void {\n  data.ns = 'http://www.w3.org/2000/svg';\n  if (sel !== 'foreignObject' && children !== undefined) {\n    for (let i = 0; i < children.length; ++i) {\n      let childData = children[i].data;\n      if (childData !== undefined) {\n        addNS(childData, (children[i] as VNode).children as VNodes, children[i].sel);\n      }\n    }\n  }\n}\n\nexport function h(sel: string): VNode;\nexport function h(sel: string, data: VNodeData): VNode;\nexport function h(sel: string, children: VNodeChildren): VNode;\nexport function h(sel: string, data: VNodeData, children: VNodeChildren): VNode;\nexport function h(sel: any, b?: any, c?: any): VNode {\n  var data: VNodeData = {}, children: any, text: any, i: number;\n  if (c !== undefined) {\n    data = b;\n    if (is.array(c)) { children = c; }\n    else if (is.primitive(c)) { text = c; }\n    else if (c && c.sel) { children = [c]; }\n  } else if (b !== undefined) {\n    if (is.array(b)) { children = b; }\n    else if (is.primitive(b)) { text = b; }\n    else if (b && b.sel) { children = [b]; }\n    else { data = b; }\n  }\n  if (children !== undefined) {\n    for (i = 0; i < children.length; ++i) {\n      if (is.primitive(children[i])) children[i] = vnode(undefined, undefined, undefined, children[i], undefined);\n    }\n  }\n  if (\n    sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n    (sel.length === 3 || sel[3] === '.' || sel[3] === '#')\n  ) {\n    addNS(data, children, sel);\n  }\n  return vnode(sel, data, children, text, undefined);\n};\nexport default h;\n","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","const equal = require('fast-deep-equal')\n\nmodule.exports = {\n  query: (name, params, options) => {\n    return { name: name, params: params, options: options || {} }\n  },\n  merge: (...args) => args.flat().reduce((a, b) => {\n    const result = {}\n    for (let key of Object.keys(a)) result[key] = a[key]\n    for (let key of Object.keys(b)) {\n      if (result[key]) {\n        if (result[key].name !== b[key].name)\n          console.error('Cannot merge OdoQL queries, names are different',\n            `${result[key].name} !== ${b[key].name}`)\n        else if (!equal(result[key].params, b[key].params))\n          console.error('Cannot merge OdoQL queries, params are different',\n            `${JSON.stringify(result[key].params)} !== ${JSON.stringify(b[key].params)}`)\n        else if (b[key].options) {\n          for (let option of Object.keys(b[key].options)) {\n            const resultoption = results[key].options[option]\n            const boption = b[key].options[option]\n            if (resultoption && !equal(resultoption, boption))\n              console.error('Cannot merge OdoQL queries, options are different',\n                `${JSON.stringify(resultoption)} !== ${JSON.stringify(boption)}`)\n            else\n              results[key].options[option] = boption\n          }\n        }\n      }\n      else result[key] = b[key]\n    }\n    return result\n  }),\n  component: (spec) => {\n    spec = Object.assign({}, spec)\n    const res = (state, params, hub) => spec.render(state, params, hub)\n    if (spec.query) res.query = (...args) => spec.query(...args)\n    else res.query = () => {}\n    return res\n  }\n}\n","const inject = () => {\n  let bindings = {}\n  return {\n    bind: (key, item) => {\n      if (typeof(key) === 'object') {\n        for (let k in key) res.bind(k, key[k])\n        return {\n          off: () => {\n            for (let k in key) {\n              if (bindings[key] == null) continue\n              const items = bindings[key]\n              const index = items.indexOf(key[k])\n              if (index !== -1) items.splice(index, 1)\n            }\n          }\n        }\n      }\n      if (bindings[key] == null) bindings[key] = []\n      if (Array.isArray(item)) {\n        bindings[key] = bindings[key].concat(item)\n        return {\n          off: () => {\n            for (let i of item) {\n              if (bindings[key] == null) continue\n              const items = bindings[key]\n              const index = items.indexOf(i)\n              if (index !== -1) items.splice(index, 1)\n            }\n          }\n        }\n      }\n\n      bindings[key].push(item)\n      return {\n        off: () => {\n          if (bindings[key] == null) return\n          const items = bindings[key]\n          const index = items.indexOf(item)\n          if (index !== -1) items.splice(index, 1)\n        }\n      }\n    },\n\n    one: (key) => {\n      if (bindings[key] == null) throw new Error(`${key} not found`)\n      const items = bindings[key]\n      if (items.length > 1) throw new Error(`${key} too many bound`)\n      return items[0]\n    },\n\n    oneornone: (key) => {\n      if (bindings[key] == null) return null\n      const items = bindings[key]\n      if (items.length > 1) throw new Error(`${key} too many bound`)\n      return items[0]\n    },\n\n    first: (key) => {\n      if (bindings[key] == null) throw new Error(`${key} not found`)\n      return bindings[key][0]\n    },\n\n    firstornone: (key) => {\n      if (bindings[key] == null) return null\n      return bindings[key][0]\n    },\n\n    many: (key) => {\n      if (bindings[key] == null) return []\n      return bindings[key]\n    },\n\n    clear: (key) => {\n      delete bindings[key]\n    },\n\n    clearAll: () => {\n      bindings = {}\n    }\n  }\n}\n\nlet _inject = inject()\nmodule.exports = (key, item) => {\n  if (key == null) return inject()\n  return _inject.bind(key, item)\n}\nmodule.exports.bind = (key, item) => _inject.bind(key, item)\nmodule.exports.one = (key) => _inject.one(key)\nmodule.exports.oneornone = (key) => _inject.oneornone(key)\nmodule.exports.first = (key) => _inject.first(key)\nmodule.exports.firstornone = (key) => _inject.firstornone(key)\nmodule.exports.many = (key) => _inject.many(key)\nmodule.exports.clear = (key) => _inject.clear(key)\nmodule.exports.clearAll = () => _inject.clearAll()\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n","const pathtoregexp = require('path-to-regexp')\n\nconst hostname = window.location.hostname\nconst hostnameparts = hostname.split('.')\nlet subdomain = null\nif (hostnameparts.length == 3) subdomain = hostnameparts[0]\n\nconst route = () => {\n  let routes = []\n  const res = (pattern, callback, options) => {\n    if (pattern === '*') pattern = '(.*)'\n    let index = 0\n    if (options != null && options.index != null) index = options.index\n    const entry = {\n      pattern: pattern,\n      index: index,\n      match: pathtoregexp(pattern, options),\n      cb: callback\n    }\n    routes.push(entry)\n    routes.sort((a, b) => b.index - a.index)\n    return {\n      off: () => {\n        const index = routes.indexOf(entry)\n        if (index != -1) routes.splice(index, 1)\n      }\n    }\n  }\n  res.exec = (url, next) => {\n    const qindex = url.indexOf('?')\n    let querystring = null\n    if (qindex !== -1) {\n      querystring = url.slice(qindex + 1)\n      url = url.slice(0, qindex)\n    }\n    for (let r of routes) {\n      const result = r.match.exec(url)\n      if (result == null) continue\n      const params = {}\n      r.match.keys.forEach((key, i) => {\n        const val = decodeURIComponent(result[i + 1].replace(/\\+/g, ' '))\n        if (val == null && !hasOwnProperty.call(params, key.name)) return\n        params[key.name] = val\n      })\n      return r.cb({\n        hostname: hostname,\n        subdomain: subdomain,\n        url: url,\n        params: params,\n        querystring: querystring\n      })\n    }\n    if (next == null) throw new Error('no route found')\n    next()\n  }\n  res.routes = () => routes\n  res.clearAll = () => {\n    routes = []\n  }\n  return res\n}\n\nconst _route = route()\nmodule.exports = (pattern, callback, options) => {\n  if (pattern == null) return route()\n  return _route(pattern, callback, options)\n}\nmodule.exports.exec = (url, next) => _route.exec(url, next)\nmodule.exports.routes = () => _route.routes()\nmodule.exports.clearAll = () => _route.clearAll()\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.page = factory());\n}(this, (function () { 'use strict';\n\nvar isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var suffix = res[6];\n    var asterisk = res[7];\n\n    var repeat = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n    var delimiter = prefix || '/';\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$');\n    }\n  }\n\n  return function (obj) {\n    var path = '';\n    var data = obj || {};\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path);\n  var re = tokensToRegExp(tokens, options);\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i]);\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n  var lastToken = tokens[tokens.length - 1];\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken);\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = token.pattern;\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || [];\n\n  if (!isarray(keys)) {\n    options = keys;\n    keys = [];\n  } else if (!options) {\n    options = {};\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n/**\n   * Module dependencies.\n   */\n\n  \n\n  /**\n   * Short-cuts for global-object checks\n   */\n\n  var hasDocument = ('undefined' !== typeof document);\n  var hasWindow = ('undefined' !== typeof window);\n  var hasHistory = ('undefined' !== typeof history);\n  var hasProcess = typeof process !== 'undefined';\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = hasDocument && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var isLocation = hasWindow && !!(window.history.location || window.location);\n\n  /**\n   * The page instance\n   * @api private\n   */\n  function Page() {\n    // public things\n    this.callbacks = [];\n    this.exits = [];\n    this.current = '';\n    this.len = 0;\n\n    // private things\n    this._decodeURLComponents = true;\n    this._base = '';\n    this._strict = false;\n    this._running = false;\n    this._hashbang = false;\n\n    // bound functions\n    this.clickHandler = this.clickHandler.bind(this);\n    this._onpopstate = this._onpopstate.bind(this);\n  }\n\n  /**\n   * Configure the instance of page. This can be called multiple times.\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  Page.prototype.configure = function(options) {\n    var opts = options || {};\n\n    this._window = opts.window || (hasWindow && window);\n    this._decodeURLComponents = opts.decodeURLComponents !== false;\n    this._popstate = opts.popstate !== false && hasWindow;\n    this._click = opts.click !== false && hasDocument;\n    this._hashbang = !!opts.hashbang;\n\n    var _window = this._window;\n    if(this._popstate) {\n      _window.addEventListener('popstate', this._onpopstate, false);\n    } else if(hasWindow) {\n      _window.removeEventListener('popstate', this._onpopstate, false);\n    }\n\n    if (this._click) {\n      _window.document.addEventListener(clickEvent, this.clickHandler, false);\n    } else if(hasDocument) {\n      _window.document.removeEventListener(clickEvent, this.clickHandler, false);\n    }\n\n    if(this._hashbang && hasWindow && !hasHistory) {\n      _window.addEventListener('hashchange', this._onpopstate, false);\n    } else if(hasWindow) {\n      _window.removeEventListener('hashchange', this._onpopstate, false);\n    }\n  };\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {string} path\n   * @api public\n   */\n\n  Page.prototype.base = function(path) {\n    if (0 === arguments.length) return this._base;\n    this._base = path;\n  };\n\n  /**\n   * Gets the `base`, which depends on whether we are using History or\n   * hashbang routing.\n\n   * @api private\n   */\n  Page.prototype._getBase = function() {\n    var base = this._base;\n    if(!!base) return base;\n    var loc = hasWindow && this._window && this._window.location;\n\n    if(hasWindow && this._hashbang && loc && loc.protocol === 'file:') {\n      base = loc.pathname;\n    }\n\n    return base;\n  };\n\n  /**\n   * Get or set strict path matching to `enable`\n   *\n   * @param {boolean} enable\n   * @api public\n   */\n\n  Page.prototype.strict = function(enable) {\n    if (0 === arguments.length) return this._strict;\n    this._strict = enable;\n  };\n\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  Page.prototype.start = function(options) {\n    var opts = options || {};\n    this.configure(opts);\n\n    if (false === opts.dispatch) return;\n    this._running = true;\n\n    var url;\n    if(isLocation) {\n      var window = this._window;\n      var loc = window.location;\n\n      if(this._hashbang && ~loc.hash.indexOf('#!')) {\n        url = loc.hash.substr(2) + loc.search;\n      } else if (this._hashbang) {\n        url = loc.search + loc.hash;\n      } else {\n        url = loc.pathname + loc.search + loc.hash;\n      }\n    }\n\n    this.replace(url, null, true, opts.dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  Page.prototype.stop = function() {\n    if (!this._running) return;\n    this.current = '';\n    this.len = 0;\n    this._running = false;\n\n    var window = this._window;\n    this._click && window.document.removeEventListener(clickEvent, this.clickHandler, false);\n    hasWindow && window.removeEventListener('popstate', this._onpopstate, false);\n    hasWindow && window.removeEventListener('hashchange', this._onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} dispatch\n   * @param {boolean=} push\n   * @return {!Context}\n   * @api public\n   */\n\n  Page.prototype.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state, this),\n      prev = this.prevContext;\n    this.prevContext = ctx;\n    this.current = ctx.path;\n    if (false !== dispatch) this.dispatch(ctx, prev);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object=} state\n   * @api public\n   */\n\n  Page.prototype.back = function(path, state) {\n    var page = this;\n    if (this.len > 0) {\n      var window = this._window;\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      hasHistory && window.history.back();\n      this.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    } else {\n      setTimeout(function() {\n        page.show(page._getBase(), state);\n      });\n    }\n  };\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {string} from - if param 'to' is undefined redirects to 'from'\n   * @param {string=} to\n   * @api public\n   */\n  Page.prototype.redirect = function(from, to) {\n    var inst = this;\n\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page.call(this, from, function(e) {\n        setTimeout(function() {\n          inst.replace(/** @type {!string} */ (to));\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        inst.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} init\n   * @param {boolean=} dispatch\n   * @return {!Context}\n   * @api public\n   */\n\n\n  Page.prototype.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state, this),\n      prev = this.prevContext;\n    this.prevContext = ctx;\n    this.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) this.dispatch(ctx, prev);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  Page.prototype.dispatch = function(ctx, prev) {\n    var i = 0, j = 0, page = this;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled.call(page, ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  Page.prototype.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return this.exit('*', path);\n    }\n\n    var route = new Route(path, null, this);\n    for (var i = 1; i < arguments.length; ++i) {\n      this.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Handle \"click\" events.\n   */\n\n  /* jshint +W054 */\n  Page.prototype.clickHandler = function(e) {\n    if (1 !== this._which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n    // ensure link\n    // use shadow dom when available if not, fall back to composedPath()\n    // for browsers that only have shady\n    var el = e.target;\n    var eventPath = e.path || (e.composedPath ? e.composedPath() : null);\n\n    if(eventPath) {\n      for (var i = 0; i < eventPath.length; i++) {\n        if (!eventPath[i].nodeName) continue;\n        if (eventPath[i].nodeName.toUpperCase() !== 'A') continue;\n        if (!eventPath[i].href) continue;\n\n        el = eventPath[i];\n        break;\n      }\n    }\n\n    // continue ensure link\n    // el.nodeName for svg links are 'a' instead of 'A'\n    while (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName.toUpperCase()) return;\n\n    // check if link is inside an svg\n    // in this case, both href and target are always inside an object\n    var svg = (typeof el.href === 'object') && el.href.constructor.name === 'SVGAnimatedString';\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if(!this._hashbang && this._samePath(el) && (el.hash || '#' === link)) return;\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    // svg target is an object and its desired value is in .baseVal property\n    if (svg ? el.target.baseVal : el.target) return;\n\n    // x-origin\n    // note: svg links that are not relative don't call click events (and skip page.js)\n    // consequently, all svg links tested inside page.js are relative and in the same origin\n    if (!svg && !this.sameOrigin(el.href)) return;\n\n    // rebuild path\n    // There aren't .pathname and .search properties in svg links, so we use href\n    // Also, svg href is an object and its desired value is in .baseVal property\n    var path = svg ? el.href.baseVal : (el.pathname + el.search + (el.hash || ''));\n\n    path = path[0] !== '/' ? '/' + path : path;\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (hasProcess && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n    var pageBase = this._getBase();\n\n    if (path.indexOf(pageBase) === 0) {\n      path = path.substr(pageBase.length);\n    }\n\n    if (this._hashbang) path = path.replace('#!', '');\n\n    if (pageBase && orig === path && (!isLocation || this._window.location.protocol !== 'file:')) {\n      return;\n    }\n\n    e.preventDefault();\n    this.show(orig);\n  };\n\n  /**\n   * Handle \"populate\" events.\n   * @api private\n   */\n\n  Page.prototype._onpopstate = (function () {\n    var loaded = false;\n    if ( ! hasWindow ) {\n      return function () {};\n    }\n    if (hasDocument && document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      var page = this;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else if (isLocation) {\n        var loc = page._window.location;\n        page.show(loc.pathname + loc.search + loc.hash, undefined, undefined, false);\n      }\n    };\n  })();\n\n  /**\n   * Event button.\n   */\n  Page.prototype._which = function(e) {\n    e = e || (hasWindow && this._window.event);\n    return null == e.which ? e.button : e.which;\n  };\n\n  /**\n   * Convert to a URL object\n   * @api private\n   */\n  Page.prototype._toURL = function(href) {\n    var window = this._window;\n    if(typeof URL === 'function' && isLocation) {\n      return new URL(href, window.location.toString());\n    } else if (hasDocument) {\n      var anc = window.document.createElement('a');\n      anc.href = href;\n      return anc;\n    }\n  };\n\n  /**\n   * Check if `href` is the same origin.\n   * @param {string} href\n   * @api public\n   */\n\n  Page.prototype.sameOrigin = function(href) {\n    if(!href || !isLocation) return false;\n\n    var url = this._toURL(href);\n    var window = this._window;\n\n    var loc = window.location;\n    return loc.protocol === url.protocol &&\n      loc.hostname === url.hostname &&\n      loc.port === url.port;\n  };\n\n  /**\n   * @api private\n   */\n  Page.prototype._samePath = function(url) {\n    if(!isLocation) return false;\n    var window = this._window;\n    var loc = window.location;\n    return url.pathname === loc.pathname &&\n      url.search === loc.search;\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {string} val - URL component to decode\n   * @api private\n   */\n  Page.prototype._decodeURLEncodedURIComponent = function(val) {\n    if (typeof val !== 'string') { return val; }\n    return this._decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  };\n\n  /**\n   * Create a new `page` instance and function\n   */\n  function createPage() {\n    var pageInstance = new Page();\n\n    function pageFn(/* args */) {\n      return page.apply(pageInstance, arguments);\n    }\n\n    // Copy all of the things over. In 2.0 maybe we use setPrototypeOf\n    pageFn.callbacks = pageInstance.callbacks;\n    pageFn.exits = pageInstance.exits;\n    pageFn.base = pageInstance.base.bind(pageInstance);\n    pageFn.strict = pageInstance.strict.bind(pageInstance);\n    pageFn.start = pageInstance.start.bind(pageInstance);\n    pageFn.stop = pageInstance.stop.bind(pageInstance);\n    pageFn.show = pageInstance.show.bind(pageInstance);\n    pageFn.back = pageInstance.back.bind(pageInstance);\n    pageFn.redirect = pageInstance.redirect.bind(pageInstance);\n    pageFn.replace = pageInstance.replace.bind(pageInstance);\n    pageFn.dispatch = pageInstance.dispatch.bind(pageInstance);\n    pageFn.exit = pageInstance.exit.bind(pageInstance);\n    pageFn.configure = pageInstance.configure.bind(pageInstance);\n    pageFn.sameOrigin = pageInstance.sameOrigin.bind(pageInstance);\n    pageFn.clickHandler = pageInstance.clickHandler.bind(pageInstance);\n\n    pageFn.create = createPage;\n\n    Object.defineProperty(pageFn, 'len', {\n      get: function(){\n        return pageInstance.len;\n      },\n      set: function(val) {\n        pageInstance.len = val;\n      }\n    });\n\n    Object.defineProperty(pageFn, 'current', {\n      get: function(){\n        return pageInstance.current;\n      },\n      set: function(val) {\n        pageInstance.current = val;\n      }\n    });\n\n    // In 2.0 these can be named exports\n    pageFn.Context = Context;\n    pageFn.Route = Route;\n\n    return pageFn;\n  }\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {string|!Function|!Object} path\n   * @param {Function=} fn\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page.call(this, '*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(/** @type {string} */ (path), null, this);\n      for (var i = 1; i < arguments.length; ++i) {\n        this.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      this['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      this.start(path);\n    }\n  }\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n    var page = this;\n    var window = page._window;\n\n    if (page._hashbang) {\n      current = isLocation && this._getBase() + window.location.hash.replace('#!', '');\n    } else {\n      current = isLocation && window.location.pathname + window.location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    isLocation && (window.location.href = ctx.canonicalPath);\n  }\n\n  /**\n   * Escapes RegExp characters in the given string.\n   *\n   * @param {string} s\n   * @api private\n   */\n  function escapeRegExp(s) {\n    return s.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} state\n   * @api public\n   */\n\n  function Context(path, state, pageInstance) {\n    var _page = this.page = pageInstance || page;\n    var window = _page._window;\n    var hashbang = _page._hashbang;\n\n    var pageBase = _page._getBase();\n    if ('/' === path[0] && 0 !== path.indexOf(pageBase)) path = pageBase + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    var re = new RegExp('^' + escapeRegExp(pageBase));\n    this.path = path.replace(re, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = (hasDocument && window.document.title);\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? _page._decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = _page._decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = this.pathname = parts[0];\n      this.hash = _page._decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    var page = this.page;\n    var window = page._window;\n    var hashbang = page._hashbang;\n\n    page.len++;\n    if (hasHistory) {\n        window.history.pushState(this.state, this.title,\n          hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n    }\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    var page = this.page;\n    if (hasHistory) {\n        page._window.history.replaceState(this.state, this.title,\n          page._hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n    }\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} options\n   * @api private\n   */\n\n  function Route(path, options, page) {\n    var _page = this.page = page || globalPage;\n    var opts = options || {};\n    opts.strict = opts.strict || page._strict;\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathToRegexp_1(this.path, this.keys = [], opts);\n  }\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {string} path\n   * @param {Object} params\n   * @return {boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = this.page._decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Module exports.\n   */\n\n  var globalPage = createPage();\n  var page_js = globalPage;\n  var default_1 = globalPage;\n\npage_js.default = default_1;\n\nreturn page_js;\n\n})));\n","const h = require('snabbdom/h').default\nconst ql = require('odoql2')\nconst inject = require('injectinto')\nconst route = require('odo-route')\nconst page = require('page')\n\ninject('pod', (hub, exe) => {\n})\n\nroute('/', (p) => {\n  return { page: 'default' }\n})\n\nroute('/test/', (p) => {\n  alert('test')\n  return { page: 'default' }\n})\n\nroute('/catalyst/', (p) => {\n  alert('www')\n  return { page: 'default' }\n})\n\ninject('page:default', ql.component({\n  query: (state, params) => {\n    return { }\n  },\n  render: (state, params, hub) => {\n    return h('div.wrapper', [\n      h('header', [\n        h('h1', 'Mind Catalyst')\n      ]),\n      h('article', [\n        h('h1', 'Hello'),\n        h('p', 'Things'),\n        h('a', { attrs: { href: '/test/' } }, 'Test')\n      ])\n    ])\n  }\n}))\n","const h = require('snabbdom/h').default\nconst ql = require('odoql2')\nconst inject = require('injectinto')\nconst route = require('odo-route')\n\ninject('page:error', ql.component({\n  render: (state, params, hub) => {\n    return h('div.wrapper', h('article', [\n      h('h1', 'Error'),\n      h('p', params.message)\n    ]))\n  }\n}))\n","import {Hooks} from './hooks';\nimport {AttachData} from './helpers/attachto'\nimport {VNodeStyle} from './modules/style'\nimport {On} from './modules/eventlisteners'\nimport {Attrs} from './modules/attributes'\nimport {Classes} from './modules/class'\nimport {Props} from './modules/props'\nimport {Dataset} from './modules/dataset'\nimport {Hero} from './modules/hero'\n\nexport type Key = string | number;\n\nexport interface VNode {\n  sel: string | undefined;\n  data: VNodeData | undefined;\n  children: Array<VNode | string> | undefined;\n  elm: Node | undefined;\n  text: string | undefined;\n  key: Key | undefined;\n}\n\nexport interface VNodeData {\n  props?: Props;\n  attrs?: Attrs;\n  class?: Classes;\n  style?: VNodeStyle;\n  dataset?: Dataset;\n  on?: On;\n  hero?: Hero;\n  attachData?: AttachData;\n  hook?: Hooks;\n  key?: Key;\n  ns?: string; // for SVGs\n  fn?: () => VNode; // for thunks\n  args?: Array<any>; // for thunks\n  [key: string]: any; // for any other 3rd party module\n}\n\nexport function vnode(sel: string | undefined,\n                      data: any | undefined,\n                      children: Array<VNode | string> | undefined,\n                      text: string | undefined,\n                      elm: Element | Text | undefined): VNode {\n  let key = data === undefined ? undefined : data.key;\n  return {sel: sel, data: data, children: children,\n          text: text, elm: elm, key: key};\n}\n\nexport default vnode;\n","export const array = Array.isArray;\nexport function primitive(s: any): s is (string | number) {\n  return typeof s === 'string' || typeof s === 'number';\n}\n","export interface DOMAPI {\n  createElement: (tagName: any) => HTMLElement;\n  createElementNS: (namespaceURI: string, qualifiedName: string) => Element;\n  createTextNode: (text: string) => Text;\n  createComment: (text: string) => Comment;\n  insertBefore: (parentNode: Node, newNode: Node, referenceNode: Node | null) => void;\n  removeChild: (node: Node, child: Node) => void;\n  appendChild: (node: Node, child: Node) => void;\n  parentNode: (node: Node) => Node;\n  nextSibling: (node: Node) => Node;\n  tagName: (elm: Element) => string;\n  setTextContent: (node: Node, text: string | null) => void;\n  getTextContent: (node: Node) => string | null;\n  isElement: (node: Node) => node is Element;\n  isText: (node: Node) => node is Text;\n  isComment: (node: Node) => node is Comment;\n}\n\nfunction createElement(tagName: any): HTMLElement {\n  return document.createElement(tagName);\n}\n\nfunction createElementNS(namespaceURI: string, qualifiedName: string): Element {\n  return document.createElementNS(namespaceURI, qualifiedName);\n}\n\nfunction createTextNode(text: string): Text {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text: string): Comment {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode: Node, newNode: Node, referenceNode: Node | null): void {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node: Node, child: Node): void {\n  node.removeChild(child);\n}\n\nfunction appendChild(node: Node, child: Node): void {\n  node.appendChild(child);\n}\n\nfunction parentNode(node: Node): Node | null {\n  return node.parentNode;\n}\n\nfunction nextSibling(node: Node): Node | null {\n  return node.nextSibling;\n}\n\nfunction tagName(elm: Element): string {\n  return elm.tagName;\n}\n\nfunction setTextContent(node: Node, text: string | null): void {\n  node.textContent = text;\n}\n\nfunction getTextContent(node: Node): string | null {\n  return node.textContent;\n}\n\nfunction isElement(node: Node): node is Element {\n  return node.nodeType === 1;\n}\n\nfunction isText(node: Node): node is Text {\n  return node.nodeType === 3;\n}\n\nfunction isComment(node: Node): node is Comment {\n  return node.nodeType === 8;\n}\n\nexport const htmlDomApi = {\n  createElement,\n  createElementNS,\n  createTextNode,\n  createComment,\n  insertBefore,\n  removeChild,\n  appendChild,\n  parentNode,\n  nextSibling,\n  tagName,\n  setTextContent,\n  getTextContent,\n  isElement,\n  isText,\n  isComment,\n} as DOMAPI;\n\nexport default htmlDomApi;\n","import {vnode, VNode, VNodeData} from './vnode';\nexport type VNodes = Array<VNode>;\nexport type VNodeChildElement = VNode | string | number | undefined | null;\nexport type ArrayOrElement<T> = T | T[];\nexport type VNodeChildren = ArrayOrElement<VNodeChildElement>\nimport * as is from './is';\n\nfunction addNS(data: any, children: VNodes | undefined, sel: string | undefined): void {\n  data.ns = 'http://www.w3.org/2000/svg';\n  if (sel !== 'foreignObject' && children !== undefined) {\n    for (let i = 0; i < children.length; ++i) {\n      let childData = children[i].data;\n      if (childData !== undefined) {\n        addNS(childData, (children[i] as VNode).children as VNodes, children[i].sel);\n      }\n    }\n  }\n}\n\nexport function h(sel: string): VNode;\nexport function h(sel: string, data: VNodeData): VNode;\nexport function h(sel: string, children: VNodeChildren): VNode;\nexport function h(sel: string, data: VNodeData, children: VNodeChildren): VNode;\nexport function h(sel: any, b?: any, c?: any): VNode {\n  var data: VNodeData = {}, children: any, text: any, i: number;\n  if (c !== undefined) {\n    data = b;\n    if (is.array(c)) { children = c; }\n    else if (is.primitive(c)) { text = c; }\n    else if (c && c.sel) { children = [c]; }\n  } else if (b !== undefined) {\n    if (is.array(b)) { children = b; }\n    else if (is.primitive(b)) { text = b; }\n    else if (b && b.sel) { children = [b]; }\n    else { data = b; }\n  }\n  if (children !== undefined) {\n    for (i = 0; i < children.length; ++i) {\n      if (is.primitive(children[i])) children[i] = vnode(undefined, undefined, undefined, children[i], undefined);\n    }\n  }\n  if (\n    sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n    (sel.length === 3 || sel[3] === '.' || sel[3] === '#')\n  ) {\n    addNS(data, children, sel);\n  }\n  return vnode(sel, data, children, text, undefined);\n};\nexport default h;\n","import {VNode, VNodeData} from './vnode';\nimport {h} from './h';\n\nexport interface ThunkData extends VNodeData {\n  fn: () => VNode;\n  args: Array<any>;\n}\n\nexport interface Thunk extends VNode {\n  data: ThunkData;\n}\n\nexport interface ThunkFn {\n  (sel: string, fn: Function, args: Array<any>): Thunk;\n  (sel: string, key: any, fn: Function, args: Array<any>): Thunk;\n}\n\nfunction copyToThunk(vnode: VNode, thunk: VNode): void {\n  thunk.elm = vnode.elm;\n  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;\n  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args;\n  thunk.data = vnode.data;\n  thunk.children = vnode.children;\n  thunk.text = vnode.text;\n  thunk.elm = vnode.elm;\n}\n\nfunction init(thunk: VNode): void {\n  const cur = thunk.data as VNodeData;\n  const vnode = (cur.fn as any).apply(undefined, cur.args);\n  copyToThunk(vnode, thunk);\n}\n\nfunction prepatch(oldVnode: VNode, thunk: VNode): void {\n  let i: number, old = oldVnode.data as VNodeData, cur = thunk.data as VNodeData;\n  const oldArgs = old.args, args = cur.args;\n  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {\n    copyToThunk((cur.fn as any).apply(undefined, args), thunk);\n    return;\n  }\n  for (i = 0; i < (args as any).length; ++i) {\n    if ((oldArgs as any)[i] !== (args as any)[i]) {\n      copyToThunk((cur.fn as any).apply(undefined, args), thunk);\n      return;\n    }\n  }\n  copyToThunk(oldVnode, thunk);\n}\n\nexport const thunk = function thunk(sel: string, key?: any, fn?: any, args?: any): VNode {\n  if (args === undefined) {\n    args = fn;\n    fn = key;\n    key = undefined;\n  }\n  return h(sel, {\n    key: key,\n    hook: {init: init, prepatch: prepatch},\n    fn: fn,\n    args: args\n  });\n} as ThunkFn;\n\nexport default thunk;","/* global module, document, Node */\nimport {Module} from './modules/module';\nimport {Hooks} from './hooks';\nimport vnode, {VNode, VNodeData, Key} from './vnode';\nimport * as is from './is';\nimport htmlDomApi, {DOMAPI} from './htmldomapi';\n\nfunction isUndef(s: any): boolean { return s === undefined; }\nfunction isDef(s: any): boolean { return s !== undefined; }\n\ntype VNodeQueue = Array<VNode>;\n\nconst emptyNode = vnode('', {}, [], undefined, undefined);\n\nfunction sameVnode(vnode1: VNode, vnode2: VNode): boolean {\n  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\n\nfunction isVnode(vnode: any): vnode is VNode {\n  return vnode.sel !== undefined;\n}\n\ntype KeyToIndexMap = {[key: string]: number};\n\ntype ArraysOf<T> = {\n  [K in keyof T]: (T[K])[];\n}\n\ntype ModuleHooks = ArraysOf<Module>;\n\nfunction createKeyToOldIdx(children: Array<VNode>, beginIdx: number, endIdx: number): KeyToIndexMap {\n  let i: number, map: KeyToIndexMap = {}, key: Key | undefined, ch;\n  for (i = beginIdx; i <= endIdx; ++i) {\n    ch = children[i];\n    if (ch != null) {\n      key = ch.key;\n      if (key !== undefined) map[key] = i;\n    }\n  }\n  return map;\n}\n\nconst hooks: (keyof Module)[] = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\n\nexport {h} from './h';\nexport {thunk} from './thunk';\n\nexport function init(modules: Array<Partial<Module>>, domApi?: DOMAPI) {\n  let i: number, j: number, cbs = ({} as ModuleHooks);\n\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      const hook = modules[j][hooks[i]];\n      if (hook !== undefined) {\n        (cbs[hooks[i]] as Array<any>).push(hook);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm: Element) {\n    const id = elm.id ? '#' + elm.id : '';\n    const c = elm.className ? '.' + elm.className.split(' ').join('.') : '';\n    return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm: Node, listeners: number) {\n    return function rmCb() {\n      if (--listeners === 0) {\n        const parent = api.parentNode(childElm);\n        api.removeChild(parent, childElm);\n      }\n    };\n  }\n\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any, data = vnode.data;\n    if (data !== undefined) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode);\n        data = vnode.data;\n      }\n    }\n    let children = vnode.children, sel = vnode.sel;\n    if (sel === '!') {\n      if (isUndef(vnode.text)) {\n        vnode.text = '';\n      }\n      vnode.elm = api.createComment(vnode.text as string);\n    } else if (sel !== undefined) {\n      // Parse selector\n      const hashIdx = sel.indexOf('#');\n      const dotIdx = sel.indexOf('.', hashIdx);\n      const hash = hashIdx > 0 ? hashIdx : sel.length;\n      const dot = dotIdx > 0 ? dotIdx : sel.length;\n      const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n      const elm = vnode.elm = isDef(data) && isDef(i = (data as VNodeData).ns) ? api.createElementNS(i, tag)\n                                                                               : api.createElement(tag);\n      if (hash < dot) elm.setAttribute('id', sel.slice(hash + 1, dot));\n      if (dotIdx > 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\\./g, ' '));\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      if (is.array(children)) {\n        for (i = 0; i < children.length; ++i) {\n          const ch = children[i];\n          if (ch != null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\n          }\n        }\n      } else if (is.primitive(vnode.text)) {\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      i = (vnode.data as VNodeData).hook; // Reuse variable\n      if (isDef(i)) {\n        if (i.create) i.create(emptyNode, vnode);\n        if (i.insert) insertedVnodeQueue.push(vnode);\n      }\n    } else {\n      vnode.elm = api.createTextNode(vnode.text as string);\n    }\n    return vnode.elm;\n  }\n\n  function addVnodes(parentElm: Node,\n                     before: Node | null,\n                     vnodes: Array<VNode>,\n                     startIdx: number,\n                     endIdx: number,\n                     insertedVnodeQueue: VNodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n      }\n    }\n  }\n\n  function invokeDestroyHook(vnode: VNode) {\n    let i: any, j: number, data = vnode.data;\n    if (data !== undefined) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);\n      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);\n      if (vnode.children !== undefined) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          i = vnode.children[j];\n          if (i != null && typeof i !== \"string\") {\n            invokeDestroyHook(i);\n          }\n        }\n      }\n    }\n  }\n\n  function removeVnodes(parentElm: Node,\n                        vnodes: Array<VNode>,\n                        startIdx: number,\n                        endIdx: number): void {\n    for (; startIdx <= endIdx; ++startIdx) {\n      let i: any, listeners: number, rm: () => void, ch = vnodes[startIdx];\n      if (ch != null) {\n        if (isDef(ch.sel)) {\n          invokeDestroyHook(ch);\n          listeners = cbs.remove.length + 1;\n          rm = createRmCb(ch.elm as Node, listeners);\n          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);\n          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {\n            i(ch, rm);\n          } else {\n            rm();\n          }\n        } else { // Text node\n          api.removeChild(parentElm, ch.elm as Node);\n        }\n      }\n    }\n  }\n\n  function updateChildren(parentElm: Node,\n                          oldCh: Array<VNode>,\n                          newCh: Array<VNode>,\n                          insertedVnodeQueue: VNodeQueue) {\n    let oldStartIdx = 0, newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx: any;\n    let idxInOld: number;\n    let elmToMove: VNode;\n    let before: any;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (oldStartVnode == null) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n      } else if (oldEndVnode == null) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (newStartVnode == null) {\n        newStartVnode = newCh[++newStartIdx];\n      } else if (newEndVnode == null) {\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (oldKeyToIdx === undefined) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\n        if (isUndef(idxInOld)) { // New element\n          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          if (elmToMove.sel !== newStartVnode.sel) {\n            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);\n          } else {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined as any;\n            api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node);\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n    }\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n      if (oldStartIdx > oldEndIdx) {\n        before = newCh[newEndIdx+1] == null ? null : newCh[newEndIdx+1].elm;\n        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n  }\n\n  function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) {\n    let i: any, hook: any;\n    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    const elm = vnode.elm = (oldVnode.elm as Node);\n    let oldCh = oldVnode.children;\n    let ch = vnode.children;\n    if (oldVnode === vnode) return;\n    if (vnode.data !== undefined) {\n      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);\n      i = vnode.data.hook;\n      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) updateChildren(elm, oldCh as Array<VNode>, ch as Array<VNode>, insertedVnodeQueue);\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) api.setTextContent(elm, '');\n        addVnodes(elm, null, ch as Array<VNode>, 0, (ch as Array<VNode>).length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh as Array<VNode>, 0, (oldCh as Array<VNode>).length - 1);\n      } else if (isDef(oldVnode.text)) {\n        api.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh as Array<VNode>, 0, (oldCh as Array<VNode>).length - 1);\n      }\n      api.setTextContent(elm, vnode.text as string);\n    }\n    if (isDef(hook) && isDef(i = hook.postpatch)) {\n      i(oldVnode, vnode);\n    }\n  }\n\n  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\n    let i: number, elm: Node, parent: Node;\n    const insertedVnodeQueue: VNodeQueue = [];\n    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();\n\n    if (!isVnode(oldVnode)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    }\n\n    if (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } else {\n      elm = oldVnode.elm as Node;\n      parent = api.parentNode(elm);\n\n      createElm(vnode, insertedVnodeQueue);\n\n      if (parent !== null) {\n        api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm));\n        removeVnodes(parent, [oldVnode], 0, 0);\n      }\n    }\n\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\n      (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]);\n    }\n    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();\n    return vnode;\n  };\n}\n","import {VNode, VNodeData} from '../vnode';\nimport {Module} from './module';\n\nexport type Classes = Record<string, boolean>\n\nfunction updateClass(oldVnode: VNode, vnode: VNode): void {\n  var cur: any, name: string, elm: Element = vnode.elm as Element,\n      oldClass = (oldVnode.data as VNodeData).class,\n      klass = (vnode.data as VNodeData).class;\n\n  if (!oldClass && !klass) return;\n  if (oldClass === klass) return;\n  oldClass = oldClass || {};\n  klass = klass || {};\n\n  for (name in oldClass) {\n    if (!klass[name]) {\n      elm.classList.remove(name);\n    }\n  }\n  for (name in klass) {\n    cur = klass[name];\n    if (cur !== oldClass[name]) {\n      (elm.classList as any)[cur ? 'add' : 'remove'](name);\n    }\n  }\n}\n\nexport const classModule = {create: updateClass, update: updateClass} as Module;\nexport default classModule;\n","import {VNode, VNodeData} from '../vnode';\nimport {Module} from './module';\n\nexport type Props = Record<string, any>;\n\nfunction updateProps(oldVnode: VNode, vnode: VNode): void {\n  var key: string, cur: any, old: any, elm = vnode.elm,\n      oldProps = (oldVnode.data as VNodeData).props,\n      props = (vnode.data as VNodeData).props;\n\n  if (!oldProps && !props) return;\n  if (oldProps === props) return;\n  oldProps = oldProps || {};\n  props = props || {};\n\n  for (key in oldProps) {\n    if (!props[key]) {\n      delete (elm as any)[key];\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    old = oldProps[key];\n    if (old !== cur && (key !== 'value' || (elm as any)[key] !== cur)) {\n      (elm as any)[key] = cur;\n    }\n  }\n}\n\nexport const propsModule = {create: updateProps, update: updateProps} as Module;\nexport default propsModule;","import {VNode, VNodeData} from '../vnode';\nimport {Module} from './module';\n\n// because those in TypeScript are too restrictive: https://github.com/Microsoft/TSJS-lib-generator/pull/237\ndeclare global {\n  interface Element {\n    setAttribute(name: string, value: string | number | boolean): void;\n    setAttributeNS(namespaceURI: string, qualifiedName: string, value: string | number | boolean): void;\n  }\n}\n\nexport type Attrs = Record<string, string | number | boolean>\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace';\nconst colonChar = 58;\nconst xChar = 120;\n\nfunction updateAttrs(oldVnode: VNode, vnode: VNode): void {\n  var key: string, elm: Element = vnode.elm as Element,\n      oldAttrs = (oldVnode.data as VNodeData).attrs,\n      attrs = (vnode.data as VNodeData).attrs;\n\n  if (!oldAttrs && !attrs) return;\n  if (oldAttrs === attrs) return;\n  oldAttrs = oldAttrs || {};\n  attrs = attrs || {};\n\n  // update modified attributes, add new attributes\n  for (key in attrs) {\n    const cur = attrs[key];\n    const old = oldAttrs[key];\n    if (old !== cur) {\n      if (cur === true) {\n        elm.setAttribute(key, \"\");\n      } else if (cur === false) {\n        elm.removeAttribute(key);\n      } else {\n        if (key.charCodeAt(0) !== xChar) {\n          elm.setAttribute(key, cur);\n        } else if (key.charCodeAt(3) === colonChar) {\n          // Assume xml namespace\n          elm.setAttributeNS(xmlNS, key, cur);\n        } else if (key.charCodeAt(5) === colonChar) {\n          // Assume xlink namespace\n          elm.setAttributeNS(xlinkNS, key, cur);\n        } else {\n          elm.setAttribute(key, cur);\n        }\n      }\n    }\n  }\n  // remove removed attributes\n  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n  // the other option is to remove all attributes with value == undefined\n  for (key in oldAttrs) {\n    if (!(key in attrs)) {\n      elm.removeAttribute(key);\n    }\n  }\n}\n\nexport const attributesModule = {create: updateAttrs, update: updateAttrs} as Module;\nexport default attributesModule;\n","import {VNode, VNodeData} from '../vnode';\nimport {Module} from './module';\n\nexport type VNodeStyle = Record<string, string> & {\n  delayed?: Record<string, string>\n  remove?: Record<string, string>\n}\n\n// Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.\nvar raf = (typeof window !== 'undefined' && (window.requestAnimationFrame).bind(window)) || setTimeout;\nvar nextFrame = function(fn: any) { raf(function() { raf(fn); }); };\nvar reflowForced = false;\n\nfunction setNextFrame(obj: any, prop: string, val: any): void {\n  nextFrame(function() { obj[prop] = val; });\n}\n\nfunction updateStyle(oldVnode: VNode, vnode: VNode): void {\n  var cur: any, name: string, elm = vnode.elm,\n      oldStyle = (oldVnode.data as VNodeData).style,\n      style = (vnode.data as VNodeData).style;\n\n  if (!oldStyle && !style) return;\n  if (oldStyle === style) return;\n  oldStyle = oldStyle || {} as VNodeStyle;\n  style = style || {} as VNodeStyle;\n  var oldHasDel = 'delayed' in oldStyle;\n\n  for (name in oldStyle) {\n    if (!style[name]) {\n      if (name[0] === '-' && name[1] === '-') {\n        (elm as any).style.removeProperty(name);\n      } else {\n        (elm as any).style[name] = '';\n      }\n    }\n  }\n  for (name in style) {\n    cur = style[name];\n    if (name === 'delayed' && style.delayed) {\n      for (let name2 in style.delayed) {\n        cur = style.delayed[name2];\n        if (!oldHasDel || cur !== (oldStyle.delayed as any)[name2]) {\n          setNextFrame((elm as any).style, name2, cur);\n        }\n      }\n    } else if (name !== 'remove' && cur !== oldStyle[name]) {\n      if (name[0] === '-' && name[1] === '-') {\n        (elm as any).style.setProperty(name, cur);\n      } else {\n        (elm as any).style[name] = cur;\n      }\n    }\n  }\n}\n\nfunction applyDestroyStyle(vnode: VNode): void {\n  var style: any, name: string, elm = vnode.elm, s = (vnode.data as VNodeData).style;\n  if (!s || !(style = s.destroy)) return;\n  for (name in style) {\n    (elm as any).style[name] = style[name];\n  }\n}\n\nfunction applyRemoveStyle(vnode: VNode, rm: () => void): void {\n  var s = (vnode.data as VNodeData).style;\n  if (!s || !s.remove) {\n    rm();\n    return;\n  }\n  if(!reflowForced) {\n    getComputedStyle(document.body).transform;\n    reflowForced = true;\n  }\n  var name: string, elm = vnode.elm, i = 0, compStyle: CSSStyleDeclaration,\n      style = s.remove, amount = 0, applied: Array<string> = [];\n  for (name in style) {\n    applied.push(name);\n    (elm as any).style[name] = style[name];\n  }\n  compStyle = getComputedStyle(elm as Element);\n  var props = (compStyle as any)['transition-property'].split(', ');\n  for (; i < props.length; ++i) {\n    if(applied.indexOf(props[i]) !== -1) amount++;\n  }\n  (elm as Element).addEventListener('transitionend', function (ev: TransitionEvent) {\n    if (ev.target === elm) --amount;\n    if (amount === 0) rm();\n  });\n}\n\nfunction forceReflow() {\n  reflowForced = false;\n}\n\nexport const styleModule = {\n  pre: forceReflow,\n  create: updateStyle,\n  update: updateStyle,\n  destroy: applyDestroyStyle,\n  remove: applyRemoveStyle\n} as Module;\nexport default styleModule;\n","import {VNode, VNodeData} from '../vnode';\nimport {Module} from './module';\n\nexport type On = {\n  [N in keyof HTMLElementEventMap]?: (ev: HTMLElementEventMap[N]) => void\n} & {\n  [event: string]: EventListener\n};\n\nfunction invokeHandler(handler: any, vnode?: VNode, event?: Event): void {\n  if (typeof handler === \"function\") {\n    // call function handler\n    handler.call(vnode, event, vnode);\n  } else if (typeof handler === \"object\") {\n    // call handler with arguments\n    if (typeof handler[0] === \"function\") {\n      // special case for single argument for performance\n      if (handler.length === 2) {\n        handler[0].call(vnode, handler[1], event, vnode);\n      } else {\n        var args = handler.slice(1);\n        args.push(event);\n        args.push(vnode);\n        handler[0].apply(vnode, args);\n      }\n    } else {\n      // call multiple handlers\n      for (var i = 0; i < handler.length; i++) {\n        invokeHandler(handler[i], vnode, event);\n      }\n    }\n  }\n}\n\nfunction handleEvent(event: Event, vnode: VNode) {\n  var name = event.type,\n      on = (vnode.data as VNodeData).on;\n\n  // call event handler(s) if exists\n  if (on && on[name]) {\n    invokeHandler(on[name], vnode, event);\n  }\n}\n\nfunction createListener() {\n  return function handler(event: Event) {\n    handleEvent(event, (handler as any).vnode);\n  }\n}\n\nfunction updateEventListeners(oldVnode: VNode, vnode?: VNode): void {\n  var oldOn = (oldVnode.data as VNodeData).on,\n      oldListener = (oldVnode as any).listener,\n      oldElm: Element = oldVnode.elm as Element,\n      on = vnode && (vnode.data as VNodeData).on,\n      elm: Element = (vnode && vnode.elm) as Element,\n      name: string;\n\n  // optimization for reused immutable handlers\n  if (oldOn === on) {\n    return;\n  }\n\n  // remove existing listeners which no longer used\n  if (oldOn && oldListener) {\n    // if element changed or deleted we remove all existing listeners unconditionally\n    if (!on) {\n      for (name in oldOn) {\n        // remove listener if element was changed or existing listeners removed\n        oldElm.removeEventListener(name, oldListener, false);\n      }\n    } else {\n      for (name in oldOn) {\n        // remove listener if existing listener removed\n        if (!on[name]) {\n          oldElm.removeEventListener(name, oldListener, false);\n        }\n      }\n    }\n  }\n\n  // add new listeners which has not already attached\n  if (on) {\n    // reuse existing listener or create new\n    var listener = (vnode as any).listener = (oldVnode as any).listener || createListener();\n    // update vnode for listener\n    listener.vnode = vnode;\n\n    // if element changed or added we add all needed listeners unconditionally\n    if (!oldOn) {\n      for (name in on) {\n        // add listener if element was changed or new listeners added\n        elm.addEventListener(name, listener, false);\n      }\n    } else {\n      for (name in on) {\n        // add listener if new listener added\n        if (!oldOn[name]) {\n          elm.addEventListener(name, listener, false);\n        }\n      }\n    }\n  }\n}\n\nexport const eventListenersModule = {\n  create: updateEventListeners,\n  update: updateEventListeners,\n  destroy: updateEventListeners\n} as Module;\nexport default eventListenersModule;\n","module.exports = (initial) => {\n  const listeners = {}\n  const unhandled = []\n  if (initial) for (let e of Object.keys(initial)) listeners[e] = [initial[e]]\n  const emit = (e, ...args) => {\n    if (listeners[e] == null)\n      return Promise.all(unhandled.map((fn) => fn(e, ...args)))\n    return Promise.all(listeners[e].map((fn) => fn(...args)))\n  }\n\n  return {\n    on: (e, fn) => {\n      if (!listeners[e]) listeners[e] = []\n      listeners[e].push(fn)\n    },\n    off: (e, fn) => {\n      if (!listeners[e]) return\n      const index = listeners[e].indexOf(fn)\n      if (index !== -1) listeners[e].splice(index, 1)\n    },\n    emit: emit,\n    unhandled: (fn) => unhandled.push(fn),\n    unhandledOff: (fn) => {\n      const index = unhandled.indexOf(fn)\n      if (index !== -1) unhandled.splice(index, 1)\n    },\n    child: (initial) => {\n      const res = module.exports(initial)\n      res.unhandled((e, ...args) => emit(e, ...args))\n      return res\n    },\n    create: (initial) => module.exports(initial)\n  }\n}\n","const equal = require('fast-deep-equal')\n\nmodule.exports = () => {\n  const providers = {}\n  const listeners = { update: [], error: [] }\n  let missingprovider = null\n\n  let state = {}\n  let cache = {}\n\n  let plan = {\n    tasks: [],\n    atomic: {},\n\n    ready: {},\n    running: {},\n    errors: {},\n    complete: {}\n  }\n\n  const emit = (event, ...args) => {\n    for (let listener of listeners[event]) listener(...args)\n  }\n\n  const querycomplete = (key, result) => {\n    const query = plan.running[key]\n    if (query.options.cache || typeof query.options.cache == 'undefined')\n      cache[key] = { query: query, value: result }\n    delete plan.running[key]\n    delete plan.atomic[key]\n    plan.complete[key] = result\n    state[key] = result\n  }\n\n  const queryerror = (key, error) => {\n    delete plan.running[key]\n    delete plan.atomic[key]\n    plan.errors[key] = error\n  }\n\n  const executequery = (key, query) => {\n    let aborted = false\n    plan.running[key] = query\n    providers[query.name](query.params)\n      .then((result) => {\n        if (aborted) return\n        querycomplete(key, result)\n        evaluate()\n      })\n      .catch((error) => {\n        if (aborted) return\n        queryerror(key, result)\n        evaluate()\n      })\n    return { abort: () => aborted = true }\n  }\n\n  const executemissing = (queries) => {\n    let aborted = false\n    missingprovider(queries)\n      .then((results) => {\n        if (aborted) return\n        for (let key of Object.keys(results)) querycomplete(key, results[key])\n        evaluate()\n      })\n      .catch((error) => {\n        if (aborted) return\n        for (let key of Object.keys(queries)) queryerror(key, error)\n        evaluate()\n      })\n    return { abort: () => aborted = true }\n  }\n\n  const evaluate = () => {\n    // check cache\n    for (let key of Object.keys(plan.ready)) {\n      const query = plan.ready[key]\n      if (!cache[key]) continue\n      const entry = cache[key]\n      if (!equal(entry.query, query)) {\n        delete cache[key]\n        continue\n      }\n      delete plan.ready[key]\n      delete plan.atomic[key]\n      plan.complete[key] = entry.value\n      state[key] = entry.value\n    }\n\n    const errorscount = Object.keys(plan.errors).length\n    const readycount = Object.keys(plan.ready).length\n    const runningcount = Object.keys(plan.running).length\n    const atomiccount = Object.keys(plan.atomic).length\n\n    // we are finished\n    if (readycount == 0 && runningcount == 0) {\n      if (errorscount > 0) emit('error', plan.errors)\n      emit('update', state)\n      return\n    }\n\n    // we are atomic\n    if (atomiccount == 0) emit('update', state)\n\n    const missing = {}\n\n    for (let key of Object.keys(plan.ready)) {\n      const query = plan.ready[key]\n      let isready = true\n      if (query.options.require)\n        for (let dep of query.options.require)\n          if (!plan.complete[dep]) isready = false\n      if (!isready) continue\n      delete plan.ready[key]\n      if (providers[query.name]) {\n        plan.running[key] = query\n        plan.tasks.push(executequery(key, query))\n      }\n      else if (missingprovider) {\n        missing[key] = query\n        plan.running[key] = query\n      }\n      else\n        plan.errors[key] = `${query.name} not available in OdoQL`\n    }\n\n    if (Object.keys(missing).length > 0) executemissing(missing)\n  }\n\n  const run = (queries) => {\n    if (Object.keys(plan.ready).length != 0 ||\n      Object.keys(plan.running).length != 0)\n      for (let task of plan.tasks) task.abort()\n    plan = {\n      tasks: [],\n      atomic: {},\n      errors: {},\n\n      complete: {},\n      ready: {},\n      running: {}\n    }\n    for (let key of Object.keys(state)) if (!queries[key]) delete state[key]\n    for (let key of Object.keys(queries)) {\n      state[key] = null\n      const query = queries[key]\n      if (query.options.atomic || typeof query.options.atomic == 'undefined')\n        plan.atomic[key] = query\n      plan.ready[key] = query\n    }\n    evaluate()\n  }\n\n  return {\n    use: (name, fn) => {\n      if (providers[name]) throw new Error(`${name} already in use by OdoQL`)\n      providers[name] = fn\n    },\n    on: (event, fn) => listeners[event].push(fn),\n    off: (event, fn) => {\n      const index = listeners[event].indexOf(fn)\n      if (index > -1) listeners[event].splice(index, 1)\n    },\n    missing: (provider) => missingprovider = provider,\n    run: run,\n    clear: () => cache = {},\n    clearQuery: (name) => {\n      for (let key of Object.keys(cache))\n        if (cache[key].query.name == name) delete cache[key]\n    },\n    clearKey: (key) => delete cache[key],\n    now: (queries) => {\n      const missing = {}\n      const ready = {}\n\n      for (let key of Object.keys(queries)) {\n        const query = queries[key]\n        query.options.atomic = true\n        if (!providers[query.name]) missing[key] = query\n        else ready[key] = query\n      }\n\n      const results = {}\n\n      const missingkeys = Object.keys(missing)\n      return Promise.all([\n        ...Object.keys(ready).map((key) => {\n          const query = ready[key]\n          return providers[query.name](query.params).then((value) => {\n            results[key] = value\n          })\n        }),\n        (missingkeys.length > 0\n          ? missingprovider(queries).then((r) => Object.assign(results, r))\n          : Promise.resolve())\n      ])\n      .then(() => results)\n    }\n  }\n}\n","import classes from './index.styl'\n\n// extension points\nrequire('./default')\nrequire('./error')\n\n// snabbdom\nconst patch = require('snabbdom').init([\n  require('snabbdom/modules/class').default,\n  require('snabbdom/modules/props').default,\n  require('snabbdom/modules/attributes').default,\n  require('snabbdom/modules/style').default,\n  require('snabbdom/modules/eventlisteners').default,\n])\nlet current = document.querySelector('#root')\nconst update = (next) => {\n  patch(current, next)\n  current = next\n}\n\n// odo\nconst Hub = require('odo-hub')\nlet state = {}\nlet params = {}\nconst hub = Hub()\n\n// relay\nconst inject = require('injectinto')\nconst exe = require('odoql2/exe')()\nexe.on('update', (results) => {\n  state = results\n  update(inject.one(`page:${params.page}`)(state, params, hub))\n})\nhub.on('update', p => {\n  Object.assign(params, p)\n  exe.run(inject.one(`page:${params.page}`).query(state, params) || {})\n})\nhub.on('refresh all', (p) => {\n  exe.clear()\n  hub.emit('update', p)\n})\n\n// url handling\nconst page = require('page')\nconst route = require('odo-route')\npage('*', (e, next) => {\n  params = {}\n  hub.emit('update', route.exec(e.canonicalPath, () => {\n    hub.emit('update', {\n      page: 'error',\n      message: `${e.canonicalPath} not found`\n    })\n  }))\n  window.scrollTo(0, 0)\n})\n\n// execute pods\nfor (let pod of inject.many('pod')) pod(hub, exe)\n\n// start relay\npage({ hashbang: true })"]}